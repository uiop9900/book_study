## 69. 예외는 진짜 예외 상황에서만 사용하라.

### 😵‍💫 예외를 잘못사용하는 경우

```java
try {    // 성능이 2배 정도 느리다
	int i = 0;
    while(true)
    	range[i++].climb();
} catch (ArrayIndexOutOfBoundsException e) {
}
```

- 어떤 코드인지 이해하지 힘들다. → 직관적이지 않다.
- 무한루프를 돌다가 `ArrayIndexOutOfBoundsException` 가 발생하면 끝난다.

```java
for (Mountain m : range)
	m.climb();
```

### 😵‍💫 근데 왜 예외를 써서 루프를 종료했을까?

- JVM은 배열에 접근할때마다 경계가 넘지 않는지 검사한다.
- 반복문도 배열 경계에 도달하면 종료한다.

→ 이 두개가 중복이라고 생각해서 하나를 생략하려고 예외를 사용해 반복문을 종료했다.

→ 하지만 잘못된 추론!

- 예외는 예외상황을 위해서 설계되었기에 JVM 구현자 입장에서는 명확한 검사만큼의 동기가 약하다.
- 코드에 `try-catch`를 넣으면 `JVM`이 적용할 수 있는 최적화가 제한된다.
- 중복을 고려했지만 실제로는 JVM이 알아서 최적화해 중복검사 되지 않는다.

→ 예외를 사용한 반복문은 코드를 헷갈리게 하고 성능을 떨어뜨리고 제대로 동작하지 않을 수 있다.

### 😵‍💫 예외는 오직 예외상황에서만 써야 한다.

: 일상적인 제어 흐름용으로 사용해서는 안된다.

- 잘 설계된 API라면 클라이언트가 정상적인 제어흐름에서 예외를 사용할 일이 없게 해야한다.
- 특정 상태에서만 호출할 수 있는 `상태 의존적 메소드`를 제공하는 클래스는 `상태 검사 메소드`도 함께 제공한다. → 예외를 사용하지 않을 수 있다.
- 예시 - `Iterator`
    - 상태 의존적 메소드 - `next`
    - 상태 검사 메소드 - `hasNext`

```java
// 두 메서드 덕분에 표준 for 관용구를 사용할 수 있음
for (Iterator<Foo> i = collections.iterator(); i.hasNext(); ) {
	Foo foo = i.next();
}
```

- 만약 `hasNext`가 없었다면 아래와 같이 코드를 작성해야 한다. → 가독성이 떨어지고 속도도 느리다.

```java
try {
	Iterator<Foo> i = collection.iterator();
    while(true) {
    	Foo foo = i.next();
        ...
} catch (NoSuchElementException e) {
}
```

### 😵‍💫 상태 검사 메서드 대신 사용할 수 있는 선택지 → `옵셔널` 혹은 `Null` 반환

- 동기화 없이 여러 스레드가 동시에 접근 가능하거나 외부요인에 의해 상태가 변경 가능하다면 옵셔널 이나 특정값을 사용한다.
- 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업을 일부 중복 수행한다면 옵셔널이나 특정 값을 선택한다.
- 다른 모든 경우엔 상태 검사 메서드 방식이 좋다. 가독성이 좋고, 잘못 사용했을 때 발견하기 쉽기 때문이다.(상태 검사 메서드 호출을 잊었다면 메서드는 예외를 던질것이다.) 옵셔널은 괜찮지만, 특정 값은 검사하지 않고 지나쳐도 발견하기 어렵다.